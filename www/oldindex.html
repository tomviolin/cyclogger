<!DOCTYPE html>
<!-- vim:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
-->
<meta charset="utf-8">
<html lang="en">
<head>
  <title>bike monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script async src="https://maps.google.com/maps/api/js?key=AIzaSyCRYNZhuhQHIMtHsvg5UZ65gcuiIn9lSzY&loading=async&libraries=streetView&callback=initialize"
type="text/javascript"></script>
  <style type="text/css">
    xcanvas#xmyChart { position: absolute; right:0px; top:0px; left:0px; height:500px !important;}
    iframe { position: absolue; right:120px; left:150px; top:0px; }
    body  {padding:0; margin:0; position: absolute; top:0; left:0; bottom:0; right:0;}
  </style>
</head>
<body>
<div id="tardis" style="opacity: 0;position:absolute;z-index:200; top:40%; left:40%;margin:auto;width:20%;height:20%;background-image: url('tardis.gif'); background-size: cover;display:block !important;"></div>
<div id="chartcon">
  <canvas id="myChart" width="0" height="0"></canvas>
</div>
<div id="street-view" style="width:100%; height: 440px;"></div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
var tardissound; //= new Audio("dematbrief.wav");
  function setChartPos(){
    let mychart = document.getElementById("chartcon");
    let w=parseFloat(document.body.clientWidth);
    let h=document.body.clientHeight;
    mychart.width=w/3.0;
    mychart.height=h/3.0;
    mychart.style.position='absolute';
    mychart.style.width = (w/3.1)+"px";
    mychart.style.height=(h/2.3)+"px";
    mychart.style.top=0;
    mychart.style.right = 0 ;
    //mychart.style.left = (w*(2.0/3.0))+"px";
    //mychart.style.width = (w/3.0)+"px";
    mychart.style.aspectRatio = (w/h)+" / 1";
    mychart.style.zIndex = 100;
    mychart.style.backgroundColor = "#ffffffdd";
    console.log(mychart.style);
    //mychart.style.width = (w/3.0)+"px";
  }
let panorama;
let svservice;
let tardis;
function initialize() {
    tardis = document.getElementById("tardis");
    let streetview = document.getElementById("street-view")
    streetview.style.height=(parseFloat(document.body.clientHeight) - 20)+"px";
    streetview.style.opacity = 1;
    setChartPos();
    initdata();
    initChart();
    panorama = new google.maps.StreetViewPanorama(
        document.getElementById("street-view"),
        {
            position: { lat: 42.982945, lng: -87.878384 },
            pov: { heading: 0, pitch: 0 },
            zoom: 1,
        }
    );
    svservice = new google.maps.StreetViewService();
}

  const NVALUES=50; // number of data points shown on screen
  const MARKERS_PER_MILE = 20;
  const ctx = document.getElementById('myChart');


  console.log(ctx.height); 


  let anim_running = false;
  let keep_anim_running = false;
  let Speeds;
  let Labels;
  let Dists;
  let Xaxis;
  let Datapts;
  let K_XMIN = 0.0;

  let lastMapTickDistance = -1;

  let our_chart;

  function initdata(){
    anim_running = false;
    keep_anim_running = false;
    Speeds = Array(NVALUES);
    Labels = Array(NVALUES);
    Dists  = Array(NVALUES);
    Xaxis = Array(NVALUES);
    Datapts = []
    for (var i = 0; i < NVALUES;++i) {
      Xaxis[i]=i;
      Datapts.push({x:Xaxis[i]+5,y:Speeds[i]});
    }
    Datapts.push(Datapts[NVALUES-1]);
    lastepochdate = -1;
    K_XMIN = 0.0;
    lastMapClickDistance = -1;
  }
  function initChart() {
    our_chart = new Chart(ctx, {
      type: 'scatter',
      font: {size: 15},
      animation: false,
      data: {
        labels: Labels,
        datasets: [{
          label: 'speed (mph)',
          pointRadius: 2,
          cubicInterpolationMode: 'monotone',
          font: {size:15},
          fill: {value:0},
          data: Speeds,
          borderWidth: 5,
          showLine: true
        }]
      },
      options: {
        plugins: {legend: {display: false,position: 'right', labels: {font:{size:15}, pointStyleWidth: 10, boxHeight: 8, pointStyle: 'circle',usePointStyle:true }}},
        animation: false,
        layout: {
          padding: {
            left: 25
          }
        },
        scales: {
          x:{
            //bounds: 'data',
            grid: {
              color:'#000000',
              lineWidth: 2
            },
            ticks: {
              font: {size:15},
              callback: (x) => { return x+' mph'}
            },
            afterTickToLabelConversion: (axis) => {
              var axtics = [];
              var xmax=axis.max;
              var xmin=axis.min;
              for (var i = 0; i<Dists.length-1; ++i) {
                if (typeof Dists[i] !== 'undefined' && typeof Dists[i+1] !== 'undefined') {
                  if (Math.floor(Dists[i+1]*MARKERS_PER_MILE) > Math.floor(Dists[i]*MARKERS_PER_MILE)) {
                    // d0=25.65  v0=89
                    // d1=25.71  v1=90  dt = 25.70  dt-d0 / d1-d0
                    dist0=Dists[i];
                    dist1=Dists[i+1];
                    distt=Math.floor(Dists[i+1]*MARKERS_PER_MILE)/MARKERS_PER_MILE
                    frac = (distt - dist0) / (dist1 - dist0);
                    var lbl="";
                    if (i < NVALUES-1) lbl=distt+"";
                    var tik = {
                      value: Xaxis[i]+frac,
                      label: lbl,
                      color: '#ff0000'
                    };
                    //console.log("==tik==");
                    //console.log(tik);
                    //console.log("==tik==");
                    axtics.push(tik);
                  }
                } else if (typeof Dists[i] === 'undefined' && typeof Dists[i+1] !== 'undefined') {
                  //console.log("start me up!");
                  // beginning mile marker 0
                  if (true || parseFloat(Dists[i+1]) < 26.0/12/5280) {
                    var tik= {
                      value: Xaxis[i],
                      label: "start"
                    };
                    axtics.push(tik);
                  }
                }
              }
                axtics.push({
                  value: xmax,
                  label: ''
                });
              axis.ticks = axtics;
              
              axis.min=xmin;
              axis.max=xmax;
              
              //console.log('ticks set');
            }
          },
          y:{
            beginAtZero: true, min:0,max:40,
            position: 'right',
            afterBuildTicks: (axis) => [0,5,10,15,20,25,30,35,40].map(v => ({value:v})),
            grid: {color:'blue', lineWidth:2},
            ticks: { 
              callback: (x) => { return x+' mph'},
              font: {size: 15 }
            }
          }
        }
      }
    });
  }
//initdata();
function dothedew(strdata) {
  if (typeof strdata != 'undefined') {
    //console.log('incoming data!!');
    data = JSON.parse(strdata);
    //console.log(data);
    if (parseFloat(Dists[NVALUES-1]) != -1 && parseFloat(Dists[NVALUES-1]) > parseFloat(data.distance)) {
      // ** clearing system **
      initdata();
      console.log("*** clearing system ***");
    }
    let thisDistance = parseFloat(data.distance);
    if (lastMapClickDistance > -1) {
      if (thisDistance - lastMapClickDistance > 0.01) {
        mapGo();
        lastMapClickDistance = thisDistance;
      }
    } else {
      lastMapClickDistance = thisDistance;
    }
    // === SPEED ===
    Speeds.shift();
    Speeds.length = NVALUES;
    if (data.speed !== undefined) {
      Speeds[NVALUES-1] = data.speed;
    }
    // === DISTANCE ===
    Dists.shift();
    Dists.length = NVALUES;
    if (data.distance !== undefined) {
      Dists[NVALUES-1] = parseFloat(data.distance);
    }
    // === LABELS ===
    Labels.shift();
    Labels.length = NVALUES;
    Labels[NVALUES-1] = '';
    
    // === Xaxis ===
    Xaxis.shift()
    Xaxis.length = NVALUES;
    Xaxis[NVALUES-1] = Xaxis[NVALUES-2]+1;
    if (Dists[NVALUES-2] !== undefined && Dists[NVALUES-1] !== undefined) {
      //console.log("DISTS: "+Dists[NVALUES-1]+" >? "+Dists[NVALUES-2]);
      if (Math.floor(parseFloat(Dists[NVALUES-1])*MARKERS_PER_MILE) > Math.floor(parseFloat(Dists[NVALUES-2])*MARKERS_PER_MILE)) {
        //Labels[NVALUES-1] = (Math.floor(parseFloat(Dists[NVALUES-1])*10)/10)+"";
      } else if (parseFloat(Dists[NVALUES-1]) < parseFloat(Dists[NVALUES-2])) {
        // re-init system
        initdata();
      }
    }
    Datapts.shift()
    Datapts.length = NVALUES+1;
    Datapts[NVALUES-1] = { x:Xaxis[NVALUES-1], y:Speeds[NVALUES-1], label:Labels[NVALUES-1]};
    Datapts[NVALUES] = { x:Xaxis[NVALUES-1]+5, y:Speeds[NVALUES-1], label:Labels[NVALUES-1]};
    our_chart.data.datasets[0].data = Datapts;
    our_chart.labels = Labels;
    
    //our_chart.options.scales.x.min = Xaxis[0];
    //our_chart.options.scales.x.max = Xaxis[NVALUES-1];
    //our_chart.update();
    if (!anim_running) {
      //console.log("calling animatex...");
      keep_anim_running = true;
      setTimeout(animatex,0);
    }
  }
}

function animatex() {
  if (!keep_anim_running) {
    anim_running = false;
    return;
  }
  anim_running = true;
  //console.log("animatex!!");
  chart_range = NVALUES;
  curmin = Xaxis[0];
  K_XMIN = K_XMIN*0.9 + curmin*0.1;
  our_chart.options.scales.x.min = K_XMIN+2;
  our_chart.options.scales.x.max = K_XMIN+chart_range;
  our_chart.update();
  if (keep_anim_running) {
    setTimeout(animatex, 1000/20);
  }else{
    anim_running = false;
  }
}


function playSoundAsync(){
    tardissound.play();
}


function bestLink(links, ourheading) {
  var bestlink = -1;
  var bestlinkmove = 9999;
  for (var i = 0; i < links.length; ++i) {
    let move = links[i].heading - ourheading;
    while (move >= 180.0) 
      move -= 360.0;
    while (move < -180.0)
      move += 360.0;
    move = Math.abs(move);
    console.log("ourHDT="+ourheading+" links["+i+"].heading="+links[i].heading+" move="+move);
    if (move < bestlinkmove) {
      bestlinkmove = move;
      bestlink = i;
    }
  }
  if (bestlink > -1) {
    return bestlink;
  } else {
    return null;
  }
}

function nudgeToBestLink() {
  let our_pov = panorama.getPov();
  let ourheading = our_pov.heading;
  let links = panorama.getLinks();
  let bestlink = bestLink(links,ourheading);
  if (bestlink > -1) {
    // point towards best link
    // let's figure out which way we need to turn on go 1/3 of the way there, plus a fixed
    // smudge so we converge reasonably
    var getpov = panorama.getPov();
    var here = getpov.heading;
    var there = links[bestlink].heading;
    var diff = there - here;
    if (diff <= -180) diff += 360;
    if (diff > 180) diff -= 360;
    var nudge = diff/3+Math.sign(diff);
    if (Math.abs(diff) < 1) {
      getpov.heading = there;
      panorama.setPov(getpov);
    } else {
      getpov.heading += nudge;

      panorama.setPov(getpov);
      window.setTimeout(nudgeToBestLink,33);
    }
  }
}
let mapdate='';

function mapGo(){
  var our_pov = panorama.getPov();
  var ourheading = our_pov.heading;
  var links=panorama.getLinks();
  var bestlink = bestLink(links,ourheading);
  console.log(links);
  if (bestlink > -1) {
    nudgeToBestLink();
    // point in direction of move
    var getpov = panorama.getPov();
    getpov.heading = links[bestlink].heading;
    //panorama.setPov(getpov);
    svservice.getPanoramaById(links[bestlink].pano).then((e) => {
      var data=e.data;
      console.log("NEW PANO DATA! ");
      console.log(data);
      if (mapdate != "") {
        if (mapdate != data.imageDate) {
          // play tardis sound
          console.log("VWORP! VWORP!");
					playSoundAsync();
          // tardis
          tardis.style.zIndex=200;
          tardis.style.display='block';
          $(tardis).animate({opacity: 1},600,()=>{$(tardis).animate({opacity: 0},2000,function(){$(this).css("display: block")})})
        }
      }
      mapdate = data.imageDate;
      console.log(mapdate);
    });
    panorama.setPano(links[bestlink].pano);
  } else {
    console.log("NO LINKS???");
  }
}
// ************* WEBSOCKET CODE *************
let socket;// = new WebSocket("ws://"+location.host+"/wsck");
function openWebSocket() {
  socket = new WebSocket("ws://"+location.host+"/wsck");

  socket.onopen = function(e) {
      console.log("[open] Connection established");
      console.log("Sending to server");
      socket.send("reqdata");
  };

  socket.onmessage = function(event) {
      console.log(`[message] Data received from server: ${event.data}`);
      dothedew(event.data);
  };

  socket.onclose = function(event) {
      if (event.wasClean) {
          console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
      } else {
          console.log('[close] Connection died');
          window.setTimeout(openWebSocket,250);
      }
  };

  socket.onerror = function(error) {
      console.log("[error]");
  };

}

openWebSocket();

var tapped = function(e){
  //e.preventDefault();
  tardissound = new Audio("dematbrief.wav");
  tardissound.play();
  tardissound.pause();
};
document.body.addEventListener('touchstart', tapped, false);
document.body.addEventListener('mousedown', tapped, false);
document.body.addEventListener('click', tapped, false);

</script>
</body>
</html>

